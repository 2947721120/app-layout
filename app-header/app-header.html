<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../app-scroll-effects/app-scroll-effects-behavior.html">

<!--
app-header is a container for app-toolbar. It can add effects to the toolbars based on the scroll position.

Example:

    <app-header>
      <app-toolbar>
        <div title>App name</div>
      </app-toolbar>
    </app-drawer>

@demo app-header/demo.html
-->

<dom-module id="app-header">
  <style>

    :host {
      position: relative;
      display: block;
      -webkit-transform: translateZ(0);
    }

    :host > ::content > app-toolbar:first-of-type {
      -webkit-transform: translateZ(0);
    }

    :host::after {
      content: "";
      position: absolute;
      left: 0px;
      right: 0px;
      bottom: -5px;
      width: 100%;
      height: 5px;
      pointer-events: none;
      opacity: 0;
      box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
      will-change: opacity;
      -webkit-transition: opacity 0.4s;
      transition: opacity 0.4s;
      -webkit-transform: translateZ(0);
      @apply(--app-header-shadow);
    }

    :host([shadow])::after {
      opacity: 1;
    }

    :host > ::content [condensed-title] {
      opacity: 0;
      white-space: nowrap;

      -webkit-transform-origin: left top;
      transform-origin: left top;
    }

    :host > ::content [title] {
      white-space: nowrap;

      -webkit-transform-origin: left top;
      transform-origin: left top;
    }

    #clip {
      @apply(--layout-fit);
      z-index: 0;
      overflow: hidden;
    }

    #layer1,
    #layer2 {
      @apply(--layout-fit);
      pointer-events: none;
      background-size: cover;
      height: 100%;
    }

    #layer1 {
      @apply(--app-header-full-header);
    }

    #layer2 {
      @apply(--app-header-condensed-header);
      opacity: 0;
    }

    :host([no-transitions]),
    :host([no-transitions])::after,
    :host([no-transitions]) #layer1,
    :host([no-transitions]) #layer2,
    :host([no-transitions]) > ::content > app-toolbar:first-of-type {
      transition: none !important;
    }

  </style>

  <template>
    <div id="clip">
      <div id="layer2"></div>
      <div id="layer1"></div>
    </div>
    <content id="content"></content>
  </template>

<script>
  Polymer({

    is: 'app-header',

    behaviors: [
      Polymer.AppScrollEffectsBehavior
    ],

    properties: {
      /**
       *
       */
      condenses: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the header is fixed to the top and never moves away.
       */
      fixed: {
        type: Boolean,
        value: false
      },

      /**
       *
       */
      reveals: {
        type: Boolean,
        value: false
      },

      /**
       * If true, a shadow will display below the header.
       */
      shadow: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    },

    behaviors: [
      Polymer.AppScrollEffectsBehavior
    ],

    observers: [
      '_condensesChanged(condenses, isAttached)'
    ],

    /**
     * A cached offsetHeight of the current element.
     * @type {number}
     */
    _height: 0,

    /**
     * The distance in pixels the header will be translated to when scrolling.
     * @type {number}
     */
    _deltaHeight: 0,

    /**
     * The top most app-toolbar.
     * @type {Element}
     */
    _topbar: null,

    _oldHeaderY: 0,

    _oldProgress: 0,

    get _headerDy() {
      return this.fixed ? this._deltaHeight : this._height + 5;
    },

    created: function() {
      this._oldHeaderY = 0;
    },

    _condensesChanged: function() {
      this.debounce('_setup', this.setup, 1);
    },

    /**
     * Recalculates the size of the toolbar.
     *
     * @method setup
     */
    setup: function() {
      // noop if the header isn't visible
      if (this.offsetWidth === 0 && this.offsetHeight === 0) {
        return;
      }
      var firstSetup = this._height === 0;
      var scrollTop = this._clampedScrollTop;
      var currentNoTransition = this.noTransitions;
      this._height = this.offsetHeight;
      this._topbar = Polymer.dom(this).querySelector('app-toolbar');

      // prepare for measurement
      this.noTransitions = true;

      if (firstSetup || scrollTop === 0) {
        this.cancelDebouncer('_resize');
        this._deltaHeight = this._topbar ? this._height - this._topbar.offsetHeight : 0;
        this._setUpEffect();
        this._updateContainer(scrollTop, true);
      } else {
        this._updateContainer(0, true);
        this._deltaHeight = this._topbar ? this._height - this._topbar.offsetHeight : 0;
        this._setUpEffect();
        // restore the previous scroll state
        // fix issue in mobile
        this._updateContainer(this._oldScrollTop, true);
        this._layoutIfDirty();
      }
      // restore no transition
      this.noTransitions = currentNoTransition;
    },

    _updateContainer: function(scrollTop, forceUpdate) {
      if (this._height == 0) {
        return;
      }
      var progress;
      var headerY = this.reveals ? this._oldHeaderY + scrollTop - this._oldScrollTop : scrollTop;
      var clampedHeaderY = Math.min(this._headerDy, Math.max(0, headerY));
      var mayHeaderMove = !this.fixed || this.condenses;

      // condense header
      if (this._oldScrollTop >= scrollTop && scrollTop > this._deltaHeight && (!this.reveals || this.condenses)) {
        clampedHeaderY = Math.max(this._deltaHeight, clampedHeaderY);
      }
      if (this._deltaHeight === 0) {
        progress = scrollTop > 0 ? 1 : 0;
      } else {
        progress = clampedHeaderY / this._deltaHeight;
      }

      if (forceUpdate || progress !== this._oldProgress || clampedHeaderY !== this._oldHeaderY || scrollTop === 0) {
        this._runEffects(progress, mayHeaderMove ? clampedHeaderY : 0, scrollTop);
        this._transformHeader(mayHeaderMove ? clampedHeaderY : 0);
        this.fire('app-header-transform', {y: clampedHeaderY, progress: progress}, {bubbles: false});
      }
      if (!forceUpdate) {
        this._oldHeaderY = clampedHeaderY;
        this._oldScrollTop = scrollTop;
        this._oldProgress = progress;
      }
    },

    isVisible: function(headerY) {
      headerY = arguments.length === 1 ? headerY : this._oldHeaderY;
      return headerY === 0 || headerY < this._height;
    },

    isContentBelow: function(headerY) {
      if (headerY === 0) {
        return this._clampedScrollTop > 0;
      }
      return this._clampedScrollTop - this._headerDy >= 0;
    },

    _transformHeader: function(y) {
      this.transform('translate3d(0,' + (-y) + 'px, 0)');
      if (this._topbar && this.condenses) {
        this.transform('translate3d(0,' + Math.min(y, this._deltaHeight) + 'px, 0)',
            this._topbar);
      }
    }
  });
</script>

</dom-module>
