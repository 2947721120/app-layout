<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../scroll-behaviors/custom-scroller-behavior.html">
<link rel="import" href="app-header-effects.html">

<!--
app-header is a container for app-toolbar. It can add effects to the toolbars based on the scroll position.

Example:

    <app-header>
      <app-toolbar>
        <div title>App name</div>
      </app-toolbar>
    </app-drawer>

@demo app-header/demo.html
-->

<dom-module id="app-header">
  <style >
  </style>
  <style>

    :host {
      position: relative;
      display: block;
      -webkit-transform: translateZ(0);
    }

    :host > ::content > app-toolbar:first-of-type {
      -webkit-transform: translateZ(0);
    }

    :host::after {
      content: "";
      position: absolute;
      left: 0px;
      right: 0px;
      bottom: -5px;
      width: 100%;
      height: 5px;
      pointer-events: none;
      opacity: 0;
      box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
      will-change: opacity;
      -webkit-transition: opacity 0.4s;
      transition: opacity 0.4s;
      -webkit-transform: translateZ(0);
      @apply(--app-header-shadow);
    }

    :host([shadow])::after {
      opacity: 1;
    }

    :host > ::content [condensed-title] {
      opacity: 0;
      white-space: nowrap;

      -webkit-transform-origin: left top;
      transform-origin: left top;
    }

    :host > ::content [title] {
      white-space: nowrap;

      -webkit-transform-origin: left top;
      transform-origin: left top;
    }

    #clip {
      @apply(--layout-fit);
      z-index: 0;
      overflow: hidden;
    }

    #headerBg,
    #condensedHeaderBg {
      @apply(--layout-fit);
      pointer-events: none;
      background-size: cover;
    }

    #headerBg {
      @apply(--app-header-full-header);
    }

    #condensedHeaderBg {
      @apply(--app-header-condensed-header);
      opacity: 0;
    }

  </style>

  <template>
    <div id="clip">
      <div id="condensedHeaderBg"></div>
      <div id="headerBg"></div>
    </div>
    <content id="content"></content>
  </template>

<script>
  Polymer({

    is: 'app-header',

    properties: {
      /**
       * If true, the header is fixed to the top and never moves away.
       */
      fixed: {
        type: Boolean,
        value: false
      },
      /**
       * If true, a shadow will display below the header.
       */
      shadow: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },

      condenses: {
        type: Boolean,
        value: false
      },

      reveals: {
        type: Boolean,
        value: false
      },
      /**
       * Install visual effects in the header that will be triggered based on the scroll position.
       *
       * Effects available in `Polymer.AppHeaderEffects`:
       *
       *    `fade-background` Use this effect to fade in/out the background images in the header.
       *
       *    `resize-title` Use this effect to transform the main title into the condensed title.
       *
       *    `snap-resized-title` Use this effect to allow the title to transition to the condensed title quickly.
       *
       *    `waterfall` Use this effect to dynamically display a shadow below the header.
       *
       * e.g. You may combine the `waterfall` and `fade-background` effects by setting the `effects` property to
       * `waterfall fade-background`
       */
      effects: {
        type: String,
        observer: '_effectsChanged'
      },

      _noTransitions: {
        type: Boolean,
        observer: '_noTransitionChanged'
      }

    },

    behaviors: [
      Polymer.CustomScrollerBehavior,
      Polymer.IronResizableBehavior
    ],

    observers: [
      '_condensesChanged(condenses, isAttached)'
    ],

    listeners: {
      'iron-resize': '_resizeHandler'
    },

    /**
     * A cached offsetHeight of the current element.
     * @type {number}
     */
    _height: 0,

    /**
     * The distance in pixels the header will be translated to when scrolling.
     * @type {number}
     */
    _deltaHeight: 0,

    /**
     * The top most app-toolbar.
     * @type {Element}
     */
    _topbar: null,

    /**
     * List of effects handlers that will take place during scroll
     * @type {Array<Function>}
     */
    _effectsRunFn: [],

    /**
     * List of the effects definitions installed via the `effects` property
     * @type {Array<Object>}
     */
    _effects: [],

    get _clampedScrollTop() {
      return Math.max(0, this._scrollTop);
    },

    get _headerDy() {
      return this.fixed ? this._deltaHeight : this._height;
    },

    created: function() {
      this._oldHeaderY = 0;
      this._oldScrollTop = 0;
    },

    attached: function() {
      this.debounce('setup', this.setup, 1);
    },

    detached: function() {
      this._tearDownEffects();
    },

    _condensesChanged: function() {
      this.debounce('setup', this.setup, 1);
    },

    /**
     * Recalculates the size of the toolbar.
     *
     * @method setup
     */
    setup: function() {
      // noop if the header isn't visible
      if (this.offsetWidth === 0 && this.offsetHeight === 0) {
        return;
      }
      var firstSetup = this._height === 0;
      var scrollTop = this._clampedScrollTop;
      this._height = this.offsetHeight;
      this._topbar = Polymer.dom(this).querySelector('app-toolbar');

      // prepare for measurement
      this._noTransitions = true;

      if (firstSetup || scrollTop === 0) {
        this.cancelDebouncer('resize');
        this._deltaHeight = this._topbar ? this._height - this._topbar.offsetHeight : 0;
        this._setUpEffect();
        this._updateHeader(scrollTop, true);
      } else {
        this._updateHeader(0, true);
        this._deltaHeight = this._topbar ? this._height - this._topbar.offsetHeight : 0;
        this._setUpEffect();
        // restore the previous scroll state
        // fix issue in mobile
        this._updateHeader(this._oldScrollTop, true);
        this._layoutIfDirty();
      }
      this._noTransitions = false;
    },

    _layoutIfDirty: function() {
      return this.offsetWidth;
    },

    _noTransitionChanged: function(noTransition) {
      if (noTransition) {
        this.style.transition = 'none';
        if (this._topbar) {
          this._topbar.style.transition = 'none';
        }
      } else {
        this.style.transition = '';
        if (this._topbar) {
          this._topbar.style.transition = '';
        }
      }
    },

    _effectsChanged: function(effects) {
      if (!Polymer.AppHeaderEffects) {
        console.error('app header effects are not loaded');
        return;
      }
      var effectDef;
      var effectNames = effects.split(' ');

      this._tearDownEffects();

      for (var i = 0; i < effectNames.length; i++) {
        if ((effectDef = Polymer.AppHeaderEffects[effectNames[i]])) {
          this._effects.push(effectDef);
        } else {
          console.error('undefined effect `' + effectNames[i] + '`');
        }
      }
      // set up new effects
      this._setUpEffect();
    },

    _setUpEffect: function() {
      if (this.isAttached) {
        this._effectsRunFn = [];
        this._effects.forEach(function(effectDef) {
          // install the effect only if no error was reported
          if (effectDef.setUp.call(this) !== false) {
            this._effectsRunFn.push(effectDef.run.bind(this));
          }
        }, this);
      }
    },

    _tearDownEffects: function() {
      this._effects.forEach(function(effectDef) {
        effectDef.tearDown.call(this);
      }, this);
      this._effectsRunFn = [];
      this._effects = [];
    },

    _runEffects: function(p, y) {
      for (var i = 0; i < this._effectsRunFn.length; i++) {
        this._effectsRunFn[i](p, y);
      }
    },

    effect: function(effectName) {
      var effectDef = Polymer.AppHeaderEffects[effectName];
      if (!effectDef) {
        throw new ReferenceError('undefined effect `' + effectName + '`');
        return;
      }
      var prop = {
        run: effectDef.run.bind(this),
        setUp: effectDef.setUp.bind(this),
        tearDown: effectDef.tearDown.bind(this)
      };
      prop.setUp();
      return prop;
    },

    _scrollHandler: function() {
      this._updateHeader(this._clampedScrollTop);
    },

    _updateHeader: function(scrollTop, forceUpdate) {
      if (this._height == 0) {
        return;
      }
      var progress;
      var headerY = this.reveals ? this._oldHeaderY + scrollTop - this._oldScrollTop : scrollTop;
      var clampedHeaderY = Math.min(this._headerDy, Math.max(0, headerY));
      var mayHeaderMove = !this.fixed || this.condenses;

      // condense header
      if (this._oldScrollTop >= scrollTop && scrollTop > this._deltaHeight && (!this.reveals || this.condenses)) {
        clampedHeaderY = Math.max(this._deltaHeight, clampedHeaderY);
      }
      if (this._deltaHeight === 0) {
        progress = scrollTop > 0 ? 1 : 0;
      } else {
        progress = clampedHeaderY / this._deltaHeight;
      }
      if (forceUpdate || clampedHeaderY !== this._oldHeaderY || scrollTop === 0) {
        this._runEffects(progress, mayHeaderMove ? clampedHeaderY : 0);
        this._transformHeader(mayHeaderMove ? clampedHeaderY : 0);
        this.fire('app-header-transform', {y: clampedHeaderY, progress: progress}, {bubbles: false});
      }
      if (!forceUpdate) {
        this._oldHeaderY =  clampedHeaderY;
        this._oldScrollTop = scrollTop;
      }
    },

    _isVisible: function(headerY) {
      return headerY === 0 || headerY < this._height;
    },

    _isContentBelow: function(headerY) {
      if (headerY === 0) {
        return this._clampedScrollTop > 0;
      }
      return this._clampedScrollTop - this._headerDy >= 0;
    },

    _transformHeader: function(y) {
      this.transform('translate3d(0,' + (-y) + 'px, 0)');
      if (this._topbar && this.condenses) {
        this.transform('translate3d(0,' + Math.min(y, this._deltaHeight) + 'px, 0)',
            this._topbar);
      }
    },

    _resizeHandler: function(e) {
      this.debounce('resize', this.setup, 100);
    }
  });
</script>

</dom-module>
