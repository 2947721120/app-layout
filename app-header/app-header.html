<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>

  customElements.define('app-header',
    class AppHeader extends HTMLElement {
      get template() {
        var layoutFit = `
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
        `;

        return `
          <style>

            :host {
              position: relative;
              display: block;
              transition-timing-function: linear;
              transition-property: transform;
            }

            :host::after {
              position: absolute;
              right: 0px;
              bottom: -5px;
              left: 0px;
              width: 100%;
              height: 5px;
              content: "";
              transition: opacity 0.4s;
              pointer-events: none;
              opacity: 0;
              box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
              will-change: opacity;
            }

            :host([shadow])::after {
              opacity: 1;
            }

            #background {
              ${layoutFit}
              overflow: hidden;
            }

            #backgroundFrontLayer,
            #backgroundRearLayer {
              ${layoutFit}
              height: 100%;
              pointer-events: none;
              background-size: cover;
            }

            #backgroundRearLayer {
              opacity: 0;
            }

            #contentContainer {
              position: relative;
              width: 100%;
              height: 100%;
            }

            :host([disabled]),
            :host([disabled])::after,
            :host([disabled]) #backgroundFrontLayer,
            :host([disabled]) #backgroundRearLayer,
            :host([disabled]) ::slotted(app-toolbar:first-of-type),
            :host([disabled]) ::slotted([primary]),
            /* Silent scrolling should not run CSS transitions */
            :host-context(.app-layout-silent-scroll),
            :host-context(.app-layout-silent-scroll)::after,
            :host-context(.app-layout-silent-scroll) #backgroundFrontLayer,
            :host-context(.app-layout-silent-scroll) #backgroundRearLayer,
            :host-context(.app-layout-silent-scroll) ::slotted(app-toolbar:first-of-type),
            :host-context(.app-layout-silent-scroll) ::slotted([primary]) {
              transition: none !important;
            }

          </style>
          <div id="contentContainer">
            <slot></slot>
          </div>
        `;
      }

      constructor() {
        super();
        this._height = 0;
        this._dHeight = 0;
        this._primaryElTop = 0;
        this._primaryEl = null;
        this._top = 0;
        this._progress = 0;
        this._wasScrollingDown = false;
        this._initScrollTop = 0;
        this._initTimestamp = 0;
        this._lastTimestamp = 0;
        this._lastScrollTop = 0;
        this._resizeHandler = this._resizeHandler.bind(this);
        this._effects$ = [];

        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = this.template;
      }

      connectedCallback() {
        // `isConnected` is undefined in safari even using the polyfill
        if (this.isConnected == null) {
          this.isConnected = true;
        }
        this.condenses = this.condenses || this.hasAttribute('condenses');
        this.fixed = this.fixed || this.hasAttribute('fixed');
        this.reveals = this.reveals || this.hasAttribute('reveals');
        this.shadow = this.shadow || this.hasAttribute('shadow');
        this.scrollTarget = this.scrollTarget || this.getAttribute('scrollTarget') || this._doc;
        this.effects = this.effects || this.getAttribute('effects') || '';

        window.addEventListener('resize', this._resizeHandler);
        requestAnimationFrame(_ => this.resetLayout());
      }

      disconnectedCallback() {
        if (this.isConnected == null) {
          this.isConnected = false;
        }
        window.removeEventListener('resize', this._resizeHandler);
      }

      attributeChangedCallback(name, o, v) {
        var desc = Object.getOwnPropertyDescriptor(this.__proto__, name);
        if (desc.set != null) {
          this[name] = v;
        }
      }

      get condenses() {
        return this._condenses;
      }

      set condenses(v) {
        this._condenses = v;
        this.resetLayout();
      }

      get fixed() {
        return this._fixed;
      }

      set fixed(v) {
        this._fixed = v;
        this.resetLayout();
      }

      get reveals() {
        return this._reveal;
      }

      set reveals(v) {
        this._reveal = v;
      }

      get shadow() {
        return this._shadow;
      }

      set shadow(v) {
        this._shadow = (v !== false && v != null);
        this._shadow ? this.setAttribute('shadow', '') : this.removeAttribute('shadow');
      }

      get _maxHeaderTop() {
        return this.fixed ? this._dHeight : this._height + 5;
      }

      /**
       * Returns a reference to the element that remains visible when the header condenses.
       *
       * @return {HTMLElement}?
       */
      _getPrimaryEl() {
        /** @type {HTMLElement} */
        var primaryEl;
        var nodes = this.shadowRoot.querySelector('slot').assignedNodes();

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeType === Node.ELEMENT_NODE) {
            var node = /** @type {HTMLElement} */ (nodes[i]);
            if (node.hasAttribute('primary')) {
              primaryEl = node;
              break;
            } else if (!primaryEl) {
              primaryEl = node;
            }
          }
        }
        return primaryEl;
      }

      /**
       * Resets the layout. If you changed the size of app-header via CSS
       * you can notify the changes by either firing the `iron-resize` event
       * or calling `resetLayout` directly.
       *
       * @method resetLayout
       */
      resetLayout() {
        if (!this.isConnected || this.fixed == null || this.condenses == null) {
          return;
        }
        if (this.offsetWidth === 0 && this.offsetHeight === 0) {
          return;
        }

        var scrollTop = this._clampedScrollTop;
        var firstSetup = this._height === 0 || scrollTop === 0;
        var currentDisabled = this.disabled;

        this._height = this.offsetHeight;
        this._primaryEl = this._getPrimaryEl();
        this.disabled = true;

        // prepare for measurement
        if  (!firstSetup) {
          this._updateScrollState(0, true);
        }

        if (this._mayMove()) {
          this._dHeight = this._primaryEl ? this._height - this._primaryEl.offsetHeight : 0;
        } else {
          this._dHeight = 0;
        }

        this._primaryElTop = this._primaryEl ? this._primaryEl.offsetTop : 0;
        this._setUpEffect();

        if (firstSetup) {
          this._updateScrollState(scrollTop, true);
        } else {
          this._updateScrollState(this._lastScrollTop, true);
          this._layoutIfDirty();
        }
        // restore no transition
        this.disabled = currentDisabled;
      }

      /**
       * Forces layout
       */
      _layoutIfDirty() {
        return this.offsetWidth;
      }

      /**
       * Returns an effect object bound to the current context.
       *
       * @param {Object} effectDef
       * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
       */
      _boundEffect(effectDef, effectsConfig) {
        effectsConfig = effectsConfig || {};
        var startsAt = parseFloat(effectsConfig.startsAt || 0);
        var endsAt = parseFloat(effectsConfig.endsAt || 1);
        var deltaS = endsAt - startsAt;
        var noop = Function();
        // fast path if possible
        var runFn = (startsAt === 0 && endsAt === 1) ? effectDef.run :
          function(progress, y) {
            effectDef.run.call(this,
                Math.max(0, (progress - startsAt) / deltaS), y);
          };
        return {
          setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
          run: effectDef.run ? runFn.bind(this) : noop,
          tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
        };
      }

      /**
       * Updates the scroll state.
       *
       * @param {number} scrollTop
       * @param {boolean=} forceUpdate (default: false)
       */
      _updateScrollState(scrollTop, forceUpdate) {
        if (this._height === 0) {
          return;
        }

        var progress = 0;
        var top = 0;
        var lastTop = this._top;
        var lastScrollTop = this._lastScrollTop;
        var maxHeaderTop = this._maxHeaderTop;
        var dScrollTop = scrollTop - this._lastScrollTop;
        var absDScrollTop = Math.abs(dScrollTop);
        var isScrollingDown = scrollTop > this._lastScrollTop;
        var now = Date.now();

        if (this._mayMove()) {
          top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
        }

        if (scrollTop >= this._dHeight) {
          top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
          this.style.transitionDuration = '0ms';
        }

        if (this.reveals && !this.disabled && absDScrollTop < 100) {
          // set the initial scroll position
          if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
            this._initScrollTop = scrollTop;
            this._initTimestamp = now;
          }

          if (scrollTop >= maxHeaderTop) {
            // check if the header is allowed to snap
            if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
              if (isScrollingDown && scrollTop >= maxHeaderTop) {
                top = maxHeaderTop;
              } else if (!isScrollingDown && scrollTop >= this._dHeight) {
                top = this.condenses && !this.fixed ? this._dHeight : 0;
              }
              var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
              this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
            } else {
              top = this._top;
            }
          }
        }

        if (this._dHeight === 0) {
          progress = scrollTop > 0 ? 1 : 0;
        } else {
          progress = top / this._dHeight;
        }

        if (!forceUpdate) {
          this._lastScrollTop = scrollTop;
          this._top = top;
          this._wasScrollingDown = isScrollingDown;
          this._lastTimestamp = now;
        }

        if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
          this._progress = progress;
          this._runEffects(progress, top);
          this._transformHeader(top);
        }
      }

      /**
       * Returns true if the current header is allowed to move as the user scrolls.
       *
       * @return {boolean}
       */
      _mayMove() {
        return this.condenses || !this.fixed;
      }

      /**
       * Returns true if the current header will condense based on the size of the header
       * and the `consenses` property.
       *
       * @return {boolean}
       */
      willCondense() {
        return this._dHeight > 0 && this.condenses;
      }

      /**
       * Returns true if the current element is on the screen.
       * That is, visible in the current viewport.
       *
       * @method isOnScreen
       * @return {boolean}
       */
      isOnScreen() {
        return this._height !== 0 && this._top < this._height;
      }

      /**
       * Returns true if there's content below the current element.
       *
       * @method isContentBelow
       * @return {boolean}
       */
      isContentBelow() {
        if (this._top === 0) {
          return this._clampedScrollTop > 0;
        }
        return this._clampedScrollTop - this._maxHeaderTop >= 0;
      }

      /**
       * Transforms the header.
       *
       * @param {number} y
       */
      _transformHeader(y) {
        this.translate3d(0, (-y) + 'px', 0);
        if (this._primaryEl && this.condenses && y >= this._primaryElTop) {
          this.translate3d(0, (Math.min(y, this._dHeight) - this._primaryElTop) + 'px', 0,
              this._primaryEl);
        }
      }

      translate3d(x, y, z, el) {
        this.transform('translate3d(' + x + ', ' + y + ', ' + z + ')', el);
      }

      transform(matrix, el) {
        el = el || this;
        el.style.transform = matrix;
      }

      _resizeHandler() {
        this.resetLayout();
      }

      _clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      _ensureBgContainers() {
        if (!this._bgContainer) {
          this._bgContainer = document.createElement('div');
          this._bgContainer.id = 'background';

          this._bgRear = document.createElement('div');
          this._bgRear.id = 'backgroundRearLayer';
          this._bgContainer.appendChild(this._bgRear);

          this._bgFront = document.createElement('div');
          this._bgFront.id = 'backgroundFrontLayer';
          this._bgContainer.appendChild(this._bgFront);

          this.shadowRoot.insertBefore(this._bgContainer,
              this.shadowRoot.querySelector('#contentContainer'));
        }
      }

      _getDOMRef(id) {
        switch (id) {
          case 'backgroundFrontLayer':
            this._ensureBgContainers();
            return this._bgFront;
          case 'backgroundRearLayer':
            this._ensureBgContainers();
            return this._bgRear;
          case 'background':
            this._ensureBgContainers();
            return this._bgContainer;
          case 'title':
            return this.querySelector('[title]');
          case 'condensedTitle':
            return this.querySelector('[condensed-title]');
        }
        return null;
      }

      /**
       * Returns an object containing the progress value of the scroll effects
       * and the top position of the header.
       *
       * @method getScrollState
       * @return {Object}
       */
      getScrollState() {
        return { progress: this._progress, top: this._top };
      }

      /* #pragma Polymer.AppScrollEffectsBehavior */

      /**
       * The clamped value of `_scrollTop`.
       * @type number
       */
      get _clampedScrollTop() {
        return Math.max(0, this._scrollTop);
      }

      get effects() {
        return this._effects;
      }

      set effects(v) {
        this._effects = v;
        this._effectsChanged();
      }

      get effectsConfig() {
        return this._effectsConfig;
      }

      set effectsConfig(v) {
        this._effectsConfig = v;
        this._effectsChanged();
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(v) {
        this._disabled = v;
        v ? this.setAttribute('disabled', '') : this.removeAttribute('disabled');
      }

      _effectsChanged() {
        this._tearDownEffects();

        if (this.effects === '' || !this.isConnected) {
          return;
        }
        var effectsConfig = this.effectsConfig || {};
        this.effects.split(' ').forEach(effectName => {
          var effectDef;
          if (effectName !== '') {
            if ((effectDef = Polymer.AppLayout._scrollEffects[effectName])) {
              this._effects$.push(this._boundEffect(effectDef, effectsConfig[effectName]));
            } else {
              console.error(this._getUndefinedMsg(effectName));
            }
          }
        });

        this._setUpEffect();
      }

      /**
       * Sets up the effects.
       */
      _setUpEffect() {
        if (!this.isConnected) {
          return;
        }
        this._effectsRunFn$ = [];
        this._effects$.forEach(effectDef => {
          // install the effect only if no error was reported
          if (effectDef.setUp() !== false) {
            this._effectsRunFn$.push(effectDef.run);
          }
        });
      }

      /**
       * Tears down the effects.
       */
      _tearDownEffects() {
        this._effects$.forEach(effectDef => effectDef.tearDown());
        this._effectsRunFn$ = [];
        this._effects$ = [];
      }

      /**
       * Runs the effects.
       *
       * @param {number} p The progress
       * @param {number} y The top position of the current element relative to the viewport.
       */
      _runEffects(p, y) {
        this._effectsRunFn$.forEach(run => run(p, y));
      }

      /**
       * Overrides the `_scrollHandler`.
       */
      _scrollHandler() {
        if (!this.disabled) {
          this._updateScrollState(this._clampedScrollTop);
        }
      }

      _getUndefinedMsg(effectName) {
        return 'Scroll effect `' + effectName + '` is undefined. ' +
            'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
      }

      /* #pragma Polymer.IronScrollTargetBehavior */

      get scrollTarget() {
        return this._scrollTarget;
      }

      set scrollTarget(v) {
        this._scrollTarget = v;
        this._scrollTargetChanged();
      }

      _scrollTargetChanged() {
        var eventTarget;
        var scrollTarget = this.scrollTarget;

        if (this._oldScrollTarget) {
          eventTarget = this._oldScrollTarget === this._doc ? window : this._oldScrollTarget;
          eventTarget.removeEventListener('scroll', this._boundScrollHandler);
          this._oldScrollTarget = null;
        }

        if (!this.isConnected) {
          return;
        }
        // Support element id references
        if (scrollTarget === 'document') {

          this.scrollTarget = this._doc;

        } else if (typeof scrollTarget === 'string') {

          this.scrollTarget = (this.rootNode || document).getElementById(this.scrollTarget);

        } else if (this._isValidScrollTarget()) {

          eventTarget = scrollTarget === this._doc ? window : scrollTarget;
          this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
          this._oldScrollTarget = scrollTarget;

          eventTarget.addEventListener('scroll', this._boundScrollHandler);
        }
      }

      /**
       * The default scroll target. Consumers of this behavior may want to customize
       * the default scroll target.
       *
       * @type {Element}
       */
      get _defaultScrollTarget() {
        return this._doc;
      }

      /**
       * Shortcut for the document element
       *
       * @type {Element}
       */
      get _doc() {
        return this.ownerDocument.documentElement;
      }

      /**
       * Gets the number of pixels that the content of an element is scrolled upward.
       *
       * @type {number}
       */
      get _scrollTop() {
        if (this._isValidScrollTarget()) {
          return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
        }
        return 0;
      }

      /**
       * Gets the number of pixels that the content of an element is scrolled to the left.
       *
       * @type {number}
       */
      get _scrollLeft() {
        if (this._isValidScrollTarget()) {
          return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
        }
        return 0;
      }

      /**
       * Sets the number of pixels that the content of an element is scrolled upward.
       *
       * @type {number}
       */
      set _scrollTop(top) {
        if (this.scrollTarget === this._doc) {
          window.scrollTo(window.pageXOffset, top);
        } else if (this._isValidScrollTarget()) {
          this.scrollTarget.scrollTop = top;
        }
      }

      /**
       * Sets the number of pixels that the content of an element is scrolled to the left.
       *
       * @type {number}
       */
      set _scrollLeft(left) {
        if (this.scrollTarget === this._doc) {
          window.scrollTo(left, window.pageYOffset);
        } else if (this._isValidScrollTarget()) {
          this.scrollTarget.scrollLeft = left;
        }
      }

      /**
       * Scrolls the content to a particular place.
       *
       * @method scroll
       * @param {number} left The left position
       * @param {number} top The top position
       */
      scroll(left, top) {
         if (this.scrollTarget === this._doc) {
          window.scrollTo(left, top);
        } else if (this._isValidScrollTarget()) {
          this.scrollTarget.scrollLeft = left;
          this.scrollTarget.scrollTop = top;
        }
      }

      /**
       * Gets the width of the scroll target.
       *
       * @type {number}
       */
      get _scrollTargetWidth() {
        if (this._isValidScrollTarget()) {
          return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
        }
        return 0;
      }

      /**
       * Gets the height of the scroll target.
       *
       * @type {number}
       */
      get _scrollTargetHeight() {
        if (this._isValidScrollTarget()) {
          return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
        }
        return 0;
      }

      /**
       * Returns true if the scroll target is a valid HTMLElement.
       *
       * @return {boolean}
       */
      _isValidScrollTarget() {
        // BUG in the polyfill: (docElement || body) instanceof HTMLElement = false
        return this.scrollTarget && this.scrollTarget.nodeType === 1;
      }
    });

</script>
